# 0 OOP-Python面向对象
-1 Python的面向对象
-2 面向对象编程
    - 基础
    - 公有私有
    - 继承
    - 组合，Mixin
-3 魔法函数
    - 魔法函数概述
    - 构造类魔法函数
    - 运算类魔法函数
    
# 1 面向对象概述（Object Oriented Programing)
-1 OOP思想：
    -1 针对object进行编程，即以object为基本单位进行思考。它是一种思维方式。
    -2 OOA，analysis
    -3 OOD，design
    -4 OOI，implementation
    -5 OOA -> OOD -> OOI：OOP的实现过程
- 类和对象的概念
    - 类：抽象名词，代表一个集合，共性的事物，将很多事物按照某些同样属性归类到一起的一个集体
    - 对象：具象的事物，单个个体
    - 类和对象的关系
        - 一个具象，代表一类事物的某个个体
        - 一个抽象，代表一大类事物
- 类，应该包括两个内容
    - 表明事务的特征，叫属性（变量）
    - 表明事物的动作，叫方法（函数）
    
# 2 类的基本实现
- 类的命名
    - 遵守变量命名的规范
    - 大驼峰（FuckTheBitch）
    - 避开系统保留关键字，或者和系统命名相似的命名。
- 如何声明一个类
    - 必须用class关键字
    - 成员属性定义可以直接使用变量赋值
    - note_oop.py
- 实例化类

            变量 = 类名（）
- 访问对象成员
    - 使用·
    
            object.成员属性名称
            object.成员属性方法
- 可以通过默认内置变量检查类和对象的所有成员
    - 对象所有成员检查
    
            object.__dict__
    - 类的所有成员检查
    
            class_name.__dict__
            
# 3 anaconda基本使用
- 主要是一个虚拟环境管理器
- 还是一个安装包管理器
- conda list: 显示anaconda安装的包
- conda env list: 显示安娜从大的虚拟环境列表
- conda creat -n oop python=3.6，创建一个Python版本为3.6的虚拟环境，名称为oop

# 4 类和对象的成员分析
- 类和对象都可以储存成员，成员可以归类所有也可以归对象所有
- 类储存成员时使用的是与类关联的另一个对象
- 独享存储成员是存储在当前对象中。。。。。。
- 对象访问一个成员时，如果对象中没有该成员，尝试访问类中的同名成员如果对象中有此成员，一定使用对象中的成员。
- 创建对象时，对象是没有成员的。只有单独对对象属性赋值时，对象才会因而具备单独的成员。

# 5 关于self
- self,在对象方法中表示当前对象本身，如果通过对象调用一个方法，
        那么该对象自动传入到这个方法的第一个参数里面，这个‘第一个参数’指的就是self
- 

# 6 面向对象三大特性
- 继承封装多态

## 6.1 封装
- 封装就是对对象的成员进行访问限制
- 封装的三个级别
    - 公开：public
    - 受保护的：protected
    - 私有的：private
    - 这三个p，这个3p，不是关键字
- 判别对象的位置
    - 对象内部
    - 对象外部
    - 子类中
- 私有
    - 私有是最高级别的封装，只能在当前类或对象中访问
    - 在成员前面添加两个下划线
    
                class Person():
                    # name 是公用的成员
                    name = 'sun'
                    # __age就是私有成员
                    __age = 18
                    
    - Python的私有并不是真私有，是一种称为name mangling的改名策略，
        可以使用对象__classname__.attributename

- 受保护的封装
    - 受保护封装是将对象成员进行一定级别的封装，然后在类或者子类中都可以访问，但是在外部不可以
    - 封住哪个方法，在成员名字前加一个下划线即可
    
            class Person():
                _age = 22
- 公开的，公共的public
    - 公共的封装实际对成员没有任何操作。
    
## 6.2 继承
- 不重复造轮子，继承就是一个类可以获得另一个类的成员属性和方法
- 作用，减少代码，增加代码的复用功能，同事可以设置类与类直接的关系。
- 继承与被继承的概念
    - 父类、基类、超类
    - 子类、派生类
    - 他们之间是 is a 的关系
- 继承的语法，略
- 继承的特征
    - 所有类都继承自object，普天之下莫非王土，率土之滨莫非王臣
    - 子类一单继承，则可以使用除private成员外的所有内容
    - 子类继承后并不会重新赋值，而是引用父类的现有成员
    - 子类中有与父类同名的成员，优先使用子类
    - 子类如果想扩充父类的方法，可以在定义新方法的同时访问父类成员来进行代码重用，
      可以使用‘父类名.父类成员’的方式来调用父类成员，也可以使用‘super().父类成员’的格式来调用
- 继承变量函数的查找顺序问题
    - 任何情况都是优先查找自己的变量
    - 没有就去查找父类
    - 构造函数如果本类中没有定义，就去查找调用父类的构造函数
    - 如果本类中有定义，那。。。
- 构造函数
    - 特殊的函数，类实例化的同时进行调用
    - 先找子类，再找父类，找到谁就输入谁的参数
- super
    - super不是关键字，而是一个类。
    - super的作用是获取MRO，（Method Resolution Order）列表中的第一个类
    - super与父类没有任何实质性关系，但通过它可以调用到父类
    - super使用两个方法，参见在构造函数中调用父类的构造函数

- 单继承和多继承
    - 单继承：每个类只能继承一个类
    - 多继承，每个类xxx
    
- 单继承和多继承的有点
    - 单继承;
        - 传承有序，逻辑清晰，语法简单，隐患少
        - 功能不能无限扩展，只能在当前唯一的继承链中扩展
    - 多继承：
        - 有点：类的功能扩展方便
        - 缺点：继承关系容易混乱
- 菱形继承和钻石继承
    - 多个子类继承自同一个父类，又被同一个子类继承。
    - 关于多继承的MRO
        - MRO就是多继承中，用于保存继承顺序的一个列表
        - Python3本身采用C3算法来
        - 计算原则
            - 子类在父类之前
            - 多个父类，则根据继承语法中括号内类的前后顺序存放。
            - 如果多个子类继承同一个父类，孙子类则选择继承语法中第一个爹    
   
- 构造函数
    - 在对象实例化时候，自动调用的函数，相当于初始化。
        def __init__(self):
        。。。
        
                
## 6.3 多态
- 多态就是同一个对象在不同情况下有不同状态出现
- 多态不是语法，是一种设计思想
- 多态性，一中调用方式，不同的执行效果
- 多态：同一事物的多种形态 

- MIx in设计模式
    - 主要采用多继承方式对类的功能进行拓展       
        
- 使用多继承语法来实现mixin
- 使用mixin实现多继承时候要小心
    - 首先它必须表示某一单一功能，而不是某个物品
    - 之则必须单一，如果有多个功能，就写多个Mixin
    - mixin不能依赖于子类的实现
    - 子类及时没有继承这个mixin类，也能照样工作，只不过缺少了某项功能
- 优点
    - 可以不对类进行任何修改，扩充功能
    - 可以方便的组织和维护不同组件
    - 可以根据需要任意调整功能类的组合
    - 可以避免创建很多新的类，导致类的继承混乱
# 7 类相关函数    
- issubclass，是否子类
- isinstance,是否是实例
- hasattr,是否有属性
- getattr
- setattr
- delattr
- dir

# 8 类的成员描述符
- 是为了在类中对累的成员属性进行相关操作而创建的一种方式
    - get:获取属性
    - set:修改设置属性
    - delete：删除属性
- 如果想使用类的成员描述符，大概有三种方法
    - 使用类实现描述器
    - 使用属性修饰符
    - 使用property函数
                    
                    property（fget,fset,fdel,doc)
    - 案例

# 9 类的内置属性

        __dict__:以字典形式展现类的MRO
        __doc__:获取文档信息
        __name__:获取类的名称，如果在模块中，获取模块的名称
        __bases__:获取所有父类

# 10类的常用魔术方法
- 魔术方法就是不需要人为调用的方法，基本是在特定的时刻自动触发
- 魔术方法的统一特征，方法名被前后各两个下划线包围
- 操作类
    - __init__：构造函数（实际上Python 中没有‘构造函数’这个名词）
    - __new__:对象实例化方法，第一个被调用，比init还早
        - 这个魔术方法比较特殊，一般不需要使用，容易把对象搞丢
    - __call__: 对象当函数使用时触发。
    - __str__： 当对象被当做字符串时触发  
    - __repr__：返回字符串，和__str__具体区别
- 描述符相关
    - __set__
    - __get__
    - __delete__
- 属性操作相关
    - __getattr__：访问一个不存在的属性时触发
    - __setattr__：对成员属性进行设置时触发
        - 参数：
            - self,
            - 被设置的属性名词
            - 需要对属性名称设置的值
        - 作用：进行属性设置的实收进行验证或修改
        - 注意：在该方法中不能对属性直接赋值，否则死循环
 
- 运算类魔术方法
    - __gt__：进行大于判断时候触发
        - 参数（self,第二个对象）,返回值推荐布尔值
        - 案例jupyter

# 11 类和对象的三种方法
- 实例方法
    - 需要实例化对象才能使用的方法，使用过程中可能需要截止对象的其他方法完成
- 静态方法
    - 不需要实例化，通过类直接访问
- 类方法
    - 不需要实例化

# 12 抽象类
- 没有具体的实现内容的方法称为抽象方法
- 抽象方法的主要意义是规范了子类的接口和行为
- 抽象类的使用需要借助ABC模块

            import abc

- 抽象类：包含抽象方法的类，通常称为abc类。
- 抽象类的使用：
    - 抽象类可以包含抽象方法，也可以包含具体方法
    - 抽象类中可以有方法，也可以有属性
    - 抽象类不能直接实例化
    - 必须继承才可以使用，且子类或者孙子类必须去实现继承过来的抽象方法，不能逃避。
    - 假定子类没有实现所有继承的抽象方法，则子类也不允许实例化。
    - 抽象类的主要作用是设定类的标准，以便于开发的时候具有统一的规范。
    
# 13 自定义类
- 类其实是一个类定义和各种方法的自由组合
- 可以定义类和函数，然后自己通过类直接赋值
- 可以借助于MethodType实现
- 可以借助于type实现
- 利用元类，MetaClass
    - 元类是类
    - 用于创造别的类









